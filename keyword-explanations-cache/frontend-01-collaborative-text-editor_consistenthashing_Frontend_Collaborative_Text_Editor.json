{
  "videoId": "frontend-01-collaborative-text-editor",
  "title": "Frontend: Collaborative Text Editor",
  "keyword": "consistent-hashing",
  "explanation": "## consistent-hashing\n\n**Consistent hashing** is a technique used to distribute data across a dynamic set of nodes in a way that minimizes the reorganization of data when nodes are added or removed. It achieves this by mapping both the nodes and the data to a fixed range of hash values, allowing for a more balanced distribution and reducing the amount of data that needs to be relocated during changes in the node set.\n\n### How it applies in this context:\nIn the context of designing a **real-time collaborative text editor**, consistent hashing can be utilized for **document sharding**. By evenly distributing documents across multiple servers, the system can efficiently manage load and scale as the number of documents and concurrent users increases. This approach helps ensure that no single server becomes a bottleneck, thus maintaining performance and availability.\n\n### Summary Breakdown:\n- **Consistent Hashing**: A method for distributing data across nodes that minimizes data movement during node changes.\n- **Document Sharding**: The practice of partitioning documents across multiple servers to improve **scalability** and **performance**.\n- **Real-time Collaboration**: The ability for multiple users to edit documents simultaneously, requiring efficient data management.\n- **Load Balancing**: Distributing user requests evenly across servers to avoid overloading any single server.\n- **Dynamic Node Management**: The ability to add or remove servers without significant disruption to the system.\n\n### Diagram:\n```mermaid\ngraph TD\n    A[User Request] -->|Hash Document ID| B{Consistent Hashing}\n    B --> C[Server 1]\n    B --> D[Server 2]\n    B --> E[Server 3]\n    C --> F[Store Document]\n    D --> F\n    E --> F\n    F --> G[Return Document]\n```\n\n### Code Example (if applicable):\n```javascript\nclass ConsistentHashing {\n    constructor(nodes = []) {\n        this.nodes = nodes;\n        this.ring = new Map();\n        this.sortedKeys = [];\n        this.rebuildRing();\n    }\n\n    rebuildRing() {\n        this.ring.clear();\n        this.sortedKeys = [];\n        this.nodes.forEach(node => {\n            const hash = this.hash(node);\n            this.ring.set(hash, node);\n            this.sortedKeys.push(hash);\n        });\n        this.sortedKeys.sort((a, b) => a - b);\n    }\n\n    hash(key) {\n        // Simple hash function (for demonstration purposes)\n        return key.split('').reduce((prev, curr) => prev + curr.charCodeAt(0), 0) % 360;\n    }\n\n    getNode(key) {\n        if (this.ring.size === 0) return null;\n        const hash = this.hash(key);\n        let idx = this.sortedKeys.findIndex(k => k >= hash);\n        if (idx === -1) idx = 0; // Wrap around\n        return this.ring.get(this.sortedKeys[idx]);\n    }\n\n    addNode(node) {\n        this.nodes.push(node);\n        this.rebuildRing();\n    }\n\n    removeNode(node) {\n        this.nodes = this.nodes.filter(n => n !== node);\n        this.rebuildRing();\n    }\n}\n\n// Example usage\nconst ch = new ConsistentHashing(['Server1', 'Server2', 'Server3']);\nconsole.log(ch.getNode('Document123')); // Returns the server for Document123\n``` \n\nThis code demonstrates a simple implementation of consistent hashing, allowing for dynamic addition and removal of nodes while maintaining a balanced distribution of keys (in this case, document identifiers).",
  "model": "gpt-4o-mini",
  "generatedAt": "2025-07-20T04:16:32.207Z"
}